<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Waves: Hyper-Neon</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        #gameCanvas {
            position: fixed; top: 0; left: 0;
        }
        .vignette {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 90;
            background: radial-gradient(circle, transparent 60%, rgba(0,0,0,0.8) 100%);
        }
        .title-text {
            background: linear-gradient(to bottom, #fff, #bce6eb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(0,255,255,0.5));
        }
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
            opacity: 0; transition: opacity 0.4s ease;
        }
        .ui-visible { opacity: 1 !important; pointer-events: auto !important; }
        .menu-overlay {
            pointer-events: auto !important; overflow-y: auto; touch-action: pan-y;
            padding: 20px; background: rgba(5, 5, 16, 0.85); backdrop-filter: blur(8px);
        }
        .interactive { pointer-events: auto; cursor: pointer; }
        .hidden { display: none !important; }
        .stats-box {
            display: flex; gap: 30px; margin-bottom: 20px; padding: 15px 30px;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.05), transparent);
            border-top: 1px solid rgba(0, 255, 255, 0.2);
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
        }
        .stat-item { text-align: center; }
        .stat-label { font-size: 0.75rem; color: #4ecdc4; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 4px; }
        .stat-val { font-size: 1.5rem; font-weight: 900; color: #fff; text-shadow: 0 0 15px rgba(0, 255, 255, 0.5); }
        .menu-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px;
            max-width: 700px; width: 100%; padding: 10px;
        }
        .scroll-container {
            overflow-y: auto; -webkit-overflow-scrolling: touch;
            max-height: 60vh; width: 100%; padding: 0 10px;
        }
        .scroll-container .menu-grid {
            margin: 0 auto; min-width: 320px;
        }
        .menu-btn {
            background: rgba(20, 20, 35, 0.8); border: 1px solid rgba(255, 255, 255, 0.1);
            color: #ccc; padding: 15px; text-align: center; border-radius: 4px;
            cursor: pointer; transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative; overflow: hidden;
            min-height: 70px; min-width: 60px;
        }
        .menu-btn:hover {
            border-color: #00ffff; background: rgba(0, 255, 255, 0.1); color: #fff;
            transform: translateY(-3px); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }
        .menu-btn.locked { opacity: 0.8; border-color: #555; color: #777; background: rgba(10, 10, 15, 0.9); }
        .menu-btn.selected { border-color: #00ffff; background: rgba(0, 255, 255, 0.15); box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); color: #fff; }
        .launch-btn {
            position: relative; padding: 15px 40px; font-size: 1.2rem; font-weight: 900;
            letter-spacing: 2px; color: #050510; background: #00ffff; border: none;
            border-radius: 2px; cursor: pointer; box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
            transition: all 0.3s; text-transform: uppercase; width: 220px; text-align: center;
        }
        .launch-btn:hover { box-shadow: 0 0 40px rgba(0, 255, 255, 0.6); transform: scale(1.05); background: #fff; }
        .endless-btn {
            background: #d946ef; color: #050510; box-shadow: 0 0 20px rgba(217, 70, 239, 0.4);
        }
        .endless-btn:hover {
            box-shadow: 0 0 40px rgba(217, 70, 239, 0.6); background: #fff;
        }
        .nav-btn {
            margin: 5px; padding: 10px 20px; border: 1px solid rgba(255, 255, 255, 0.2);
            background: transparent; color: rgba(255, 255, 255, 0.8); cursor: pointer;
            transition: all 0.2s; border-radius: 2px; text-transform: uppercase;
            font-size: 0.8rem; letter-spacing: 2px; min-width: 120px; text-align: center;
        }
        .nav-btn:hover { border-color: #00ffff; color: #fff; background: rgba(0, 255, 255, 0.05); }
        .info-panel {
            max-width: 600px; width: 100%; text-align: center; color: #ccc;
            background: rgba(0,0,0,0.5); padding: 20px; border: 1px solid rgba(255,255,255,0.1);
        }
        .info-panel h3 { color: #0ff; font-size: 1.2rem; margin-bottom: 10px; letter-spacing: 2px; }
        .info-panel p { margin-bottom: 8px; font-size: 0.9rem; }
        #progressContainer {
            position: absolute; top: 0; left: 0; width: 100%; height: 4px;
            background: rgba(255, 255, 255, 0.05); z-index: 50; display: none;
        }
        #progressBar {
            width: 0%; height: 100%; background: linear-gradient(90deg, #00ffff, #fff);
            box-shadow: 0 0 10px #00ffff; transition: width 0.1s linear;
        }
        #soundToggle {
            position: absolute; top: 20px; right: 20px; z-index: 110;
            color: rgba(255,255,255,0.5); transition: color 0.2s;
        }
        #soundToggle:hover { color: #fff; }
        .currency-display {
            position: absolute; top: 20px; left: 20px; z-index: 110;
            color: #fbbf24; font-weight: bold; font-size: 1.2rem;
            display: flex; align-items: center; gap: 8px;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }
        /* Floating Text for Near Miss / Powerups */
        .float-text {
            position: absolute;
            font-weight: 900;
            font-style: italic;
            pointer-events: none;
            animation: floatUp 1s forwards;
            text-shadow: 0 0 10px currentColor;
            z-index: 40;
        }
        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.2); opacity: 0; }
        }
    </style>
</head>
<body>
    <div class="vignette"></div>
    <div id="floatTextContainer"></div>
    <!-- Currency Display -->
    <div class="currency-display">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-6 h-6">
            <path fill-rule="evenodd" d="M10.788 3.21c.448-1.077 1.976-1.077 2.424 0l2.082 5.007 5.404.433c1.164.093 1.636 1.545.749 2.305l-4.117 3.527 1.257 5.273c.271 1.136-.964 2.033-1.96 1.425L12 18.354 7.373 21.18c-.996.608-2.231-.29-1.96-1.425l1.257-5.273-4.117-3.527c-.887-.76-.415-2.212.749-2.305l5.404-.433 2.082-5.006z" clip-rule="evenodd" />
        </svg>
        <span id="starDisplay">0</span>
    </div>
    <!-- Audio Controls -->
    <div class="controls-container">
        <!-- SFX Toggle -->
        <button id="sfxToggle" onclick="toggleSFX()" class="icon-btn interactive" title="Toggle SFX">
            <svg id="iconSfxOn" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
              <path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" />
            </svg>
            <svg id="iconSfxOff" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8 hidden">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75L15.75 11.25m0 0l-1.5 1.5m1.5-1.5l-1.5-1.5m1.5 1.5l1.5 1.5M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
        </button>
        <!-- Music Toggle -->
        <button id="musicToggle" onclick="toggleMusic()" class="icon-btn interactive" title="Toggle Music">
            <svg id="iconMusicOn" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8">
              <path stroke-linecap="round" stroke-linejoin="round" d="M9 9l10.5-3m0 6.553v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163zm0 0V2.25L9 5.25v10.303m0 0v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 01-.99-3.467l2.31-.66A2.25 2.25 0 009 15.553z" />
            </svg>
            <svg id="iconMusicOff" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-8 h-8 hidden">
              <path stroke-linecap="round" stroke-linejoin="round" d="M3 3l18 18M9 9l10.5-3m0 6.553v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163zm0 0V2.25L9 5.25v10.303m0 0v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 01-.99-3.467l2.31-.66A2.25 2.25 0 009 15.553z" />
            </svg>
        </button>
    </div>
    <!-- Main Menu -->
    <div id="startScreen" class="ui-layer menu-overlay ui-visible">
        <div class="mb-4 text-center">
            <h1 class="text-6xl md:text-8xl font-black italic tracking-tighter title-text mb-2">
                SPACE WAVES
            </h1>
            <div class="flex items-center justify-center gap-4">
                <div class="h-px w-12 bg-cyan-500/50"></div>
                <p class="text-cyan-400 text-sm tracking-[0.5em] font-bold">HYPER EDITION</p>
                <div class="h-px w-12 bg-cyan-500/50"></div>
            </div>
        </div>
        <div class="stats-box">
            <div class="stat-item">
                <span class="stat-label">RANK</span>
                <span id="menuRank" class="stat-val text-yellow-400">ROOKIE</span>
            </div>
            <div class="w-px bg-cyan-500/30"></div>
            <div class="stat-item">
                <span class="stat-label">MAX SECTOR</span>
                <span id="menuMaxLevel" class="stat-val">1</span>
            </div>
            <div class="w-px bg-cyan-500/30"></div>
            <div class="stat-item">
                <span class="stat-label">ENDLESS BEST</span>
                <span id="menuEndlessBest" class="stat-val">0</span>
            </div>
        </div>
        <div class="relative mb-6 group cursor-pointer" onclick="showMenu('skins')">
            <div class="absolute inset-0 bg-cyan-500/20 blur-3xl rounded-full opacity-0 group-hover:opacity-100 transition-opacity duration-500"></div>
            <canvas id="menuShipCanvas" width="240" height="120" class="relative z-10"></canvas>
            <div class="absolute bottom-0 w-full text-center text-xs text-cyan-500/50 tracking-widest opacity-0 group-hover:opacity-100 transition-opacity">CHANGE SHIP</div>
        </div>
        <div class="flex flex-col gap-4 items-center w-full">
            <div class="flex gap-4">
                <button onclick="startGame('LEVELS')" class="launch-btn interactive">CAMPAIGN</button>
                <button onclick="startGame('ENDLESS')" class="launch-btn endless-btn interactive">ENDLESS</button>
            </div>
            <div class="flex flex-wrap justify-center gap-2 mt-4 max-w-lg">
                <button onclick="showMenu('levels')" class="interactive nav-btn">SECTORS</button>
                <button onclick="showMenu('skins')" class="interactive nav-btn">HANGAR</button>
                <button onclick="showMenu('tutorial')" class="interactive nav-btn">TUTORIAL</button>
                <button onclick="showMenu('credits')" class="interactive nav-btn">CREDITS</button>
            </div>
        </div>
    </div>
    <!-- Levels Menu -->
    <div id="levelsScreen" class="ui-layer menu-overlay hidden">
        <h2 class="text-4xl font-bold text-white mb-8 tracking-widest text-center mt-auto md:mt-0 title-text">SECTOR SELECT</h2>
        <div class="scroll-container">
            <div id="levelsGrid" class="menu-grid"></div>
        </div>
        <button onclick="showMenu('start')" class="interactive mt-8 nav-btn mb-auto md:mb-0">BACK</button>
    </div>
    <!-- Skins Menu -->
    <div id="skinsScreen" class="ui-layer menu-overlay hidden">
        <h2 class="text-4xl font-bold text-white mb-8 tracking-widest text-center mt-auto md:mt-0 title-text">HANGAR</h2>
        <p class="text-yellow-400 mb-4 font-bold tracking-widest">STARS: <span id="skinMenuStars">0</span></p>
        <div class="scroll-container">
            <div id="skinsGrid" class="menu-grid"></div>
        </div>
        <button onclick="showMenu('start')" class="interactive mt-8 nav-btn mb-auto md:mb-0">BACK</button>
    </div>
    <!-- Credits Screen -->
    <div id="creditsScreen" class="ui-layer menu-overlay hidden">
        <h2 class="text-4xl font-bold text-white mb-8 tracking-widest title-text">CREDITS</h2>
        <div class="info-panel">
            <div class="mb-6">
                <h3>GAME DESIGN & CODE</h3>
                <p>Gemini AI</p>
            </div>
            <div class="mb-6">
                <h3>VISUAL FX ENGINE</h3>
                <p>Canvas 2D & Tailwind CSS</p>
            </div>
            <div>
                <h3>AUDIO SYNTHESIS</h3>
                <p>Web Audio API (Procedural)</p>
            </div>
        </div>
        <button onclick="showMenu('start')" class="interactive mt-8 nav-btn">BACK</button>
    </div>
    <!-- Tutorial Screen -->
    <div id="tutorialScreen" class="ui-layer menu-overlay hidden">
        <h2 class="text-4xl font-bold text-white mb-8 tracking-widest title-text">HOW TO PLAY</h2>
        <div class="info-panel text-left">
            <div class="mb-4">
                <span class="text-cyan-400 font-bold">CONTROLS:</span> Hold <span class="text-white border border-white px-1 text-xs">SPACE</span> or <span class="text-white border border-white px-1 text-xs">TAP</span> to fly up. Release to dive.
            </div>
            <div class="mb-4">
                <span class="text-orange-400 font-bold">GRAVITY RIFTS:</span> Orange portals flip gravity! When flipped, hold space to dive DOWN.
            </div>
            <div class="mb-4">
                <span class="text-purple-400 font-bold">NEAR MISS:</span> Fly dangerously close to walls for bonus points and style.
            </div>
            <div class="mb-4">
                <span class="text-yellow-400 font-bold">ITEMS:</span>
                <ul class="list-disc pl-5 mt-1 text-sm text-gray-300">
                    <li><span class="text-cyan-300">Blue Orb:</span> Shield (Stacks)</li>
                    <li><span class="text-purple-300">Purple Orb:</span> Slow Motion</li>
                    <li><span class="text-yellow-300">Star:</span> +50 Score & Currency</li>
                </ul>
            </div>
        </div>
        <button onclick="showMenu('start')" class="interactive mt-8 nav-btn">BACK</button>
    </div>
    <!-- Game Over Screen -->
    <div id="gameOverScreen" class="ui-layer hidden bg-black/90 backdrop-blur-md">
        <h2 class="text-6xl md:text-8xl font-black text-red-500 mb-2 tracking-tighter" style="text-shadow: 0 0 40px rgba(255,0,0,0.4);">CRASHED</h2>
        <div class="w-24 h-1 bg-red-500 mb-6"></div>
        <div class="flex gap-6">
            <button id="retryBtn" onclick="startGame(lastGameMode)" class="interactive px-10 py-4 border border-red-500 text-red-500 hover:bg-red-500 hover:text-white font-bold tracking-widest transition-all text-xl">RETRY</button>
            <button onclick="goToMenu()" class="interactive px-10 py-4 border border-gray-600 text-gray-400 hover:border-white hover:text-white font-bold tracking-widest transition-all text-xl">MENU</button>
        </div>
    </div>
    <!-- Level Complete Screen -->
    <div id="levelCompleteScreen" class="ui-layer hidden bg-black/90 backdrop-blur-md">
        <h2 class="text-6xl md:text-8xl font-black text-green-400 mb-2 tracking-tighter" style="text-shadow: 0 0 40px rgba(0,255,0,0.4);">CLEARED</h2>
        <p class="text-white/60 text-lg mb-8 tracking-widest">WARP DRIVE READY</p>
        <button onclick="nextLevel()" class="interactive px-12 py-5 bg-green-500 text-black font-black tracking-widest hover:bg-white hover:scale-105 transition-all text-2xl shadow-[0_0_30px_rgba(0,255,0,0.4)]">WARP TO SECTOR <span id="nextLevelNum">2</span></button>
        <button onclick="goToMenu()" class="interactive mt-8 text-gray-500 hover:text-white text-sm tracking-widest">RETURN TO BASE</button>
    </div>
    <div id="hud" class="absolute top-4 left-6 pointer-events-none hidden z-20 flex flex-col gap-2">
        <div id="levelContainer">
            <div class="text-cyan-500/60 text-xs tracking-[0.2em] font-bold mb-1">SECTOR</div>
            <div id="levelDisplay" class="text-white text-3xl font-black" style="text-shadow: 0 0 15px rgba(0, 255, 255, 0.5)">1</div>
        </div>
        <div id="scoreContainer" class="hidden">
            <div class="text-pink-500/60 text-xs tracking-[0.2em] font-bold mb-1">DISTANCE</div>
            <div id="distanceDisplay" class="text-white text-3xl font-black" style="text-shadow: 0 0 15px rgba(217, 70, 239, 0.5)">0</div>
        </div>
        <div id="slowMoIndicator" class="mt-2 text-purple-400 text-sm font-bold tracking-widest hidden animate-pulse">TIME DILATION</div>
        <div id="gravityIndicator" class="text-orange-400 text-sm font-bold tracking-widest hidden animate-pulse">GRAVITY REVERSED</div>
    </div>
    <div id="progressContainer"><div id="progressBar"></div></div>
    <canvas id="gameCanvas"></canvas>
    <script>
        const CONFIG = {
            waveSpeed: 7.5,
            initialGameSpeed: 7.0,
            spawnRate: 1600,
            obstacleWidth: 60,
            levelDistance: 1200,
            gravity: 0,
            shieldChance: 0.15,
            pickupChance: 0.3,
            portalChance: 0.08
        };
        const SKINS = [
            { id: 'classic', name: 'V-WING', color: '#00ffff', price: 0 },
            { id: 'interceptor', name: 'STINGER', color: '#ff3333', price: 200 },
            { id: 'orb', name: 'PULSAR', color: '#33ff33', price: 500 },
            { id: 'dart', name: 'PHANTOM', color: '#ffff33', price: 1000 }
        ];
        const THEMES = [
            { name: 'Neon City', bg1: '#050510', bg2: '#0a0a1a', obs: '#ff0055', obsFill: 'rgba(255, 0, 85, 0.1)', trail: '#00ffff' },
            { name: 'Matrix',    bg1: '#000800', bg2: '#001400', obs: '#00ff00', obsFill: 'rgba(0, 255, 0, 0.1)', trail: '#ffff00' },
            { name: 'Synth',     bg1: '#0d0014', bg2: '#1a0029', obs: '#00ffff', obsFill: 'rgba(0, 255, 255, 0.1)', trail: '#ff00ff' },
            { name: 'Inferno',   bg1: '#140200', bg2: '#290500', obs: '#ff4400', obsFill: 'rgba(255, 68, 0, 0.1)', trail: '#00ccff' }
        ];
        const AudioSys = {
            ctx: null, muted: false,
            init: function() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
            toggle: function() { this.muted = !this.muted; if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); return this.muted; },
            play: function(type) {
                if (!this.ctx || this.muted) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.connect(gain); gain.connect(this.ctx.destination);
                if (type === 'crash') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(40, t+0.4);
                    gain.gain.setValueAtTime(0.3, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.4);
                    osc.start(t); osc.stop(t+0.4);
                } else if (type === 'slowmo') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(800, t); osc.frequency.exponentialRampToValueAtTime(200, t+0.5);
                    gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t+0.5);
                    osc.start(t); osc.stop(t+0.5);
                } else if (type === 'warp') {
                    osc.type = 'square'; osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(800, t+1.5);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+1.5);
                    osc.start(t); osc.stop(t+1.5);
                } else if (type === 'shieldGet') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(400, t); osc.frequency.linearRampToValueAtTime(1200, t+0.2);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.3);
                    osc.start(t); osc.stop(t+0.3);
                } else if (type === 'starGet') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(1500, t); osc.frequency.exponentialRampToValueAtTime(2000, t+0.1);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.1);
                    osc.start(t); osc.stop(t+0.1);
                } else if (type === 'portal') {
                    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(600, t+0.4);
                    gain.gain.setValueAtTime(0.15, t); gain.gain.exponentialRampToValueAtTime(0.01, t+0.4);
                    osc.start(t); osc.stop(t+0.4);
                } else if (type === 'graze') {
                    osc.type = 'triangle'; osc.frequency.setValueAtTime(1200, t); osc.frequency.exponentialRampToValueAtTime(1500, t+0.1);
                    gain.gain.setValueAtTime(0.05, t); gain.gain.linearRampToValueAtTime(0, t+0.1);
                    osc.start(t); osc.stop(t+0.1);
                } else if (type === 'buy') {
                    osc.type = 'sine'; osc.frequency.setValueAtTime(600, t); osc.frequency.linearRampToValueAtTime(1000, t+0.1);
                    gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t+0.2);
                    osc.start(t); osc.stop(t+0.2);
                }
            }
        };
        const MusicSys = {
            ctx: null, muted: false, isPlaying: false, currentTrack: null,
            timerID: null, nextNoteTime: 0, noteIndex: 0,
            toggle() {
                this.muted = !this.muted;
                if(this.muted) this.stop();
                else if(gameState === 'PLAYING') this.play(gameMode === 'ENDLESS' ? 'ENDLESS' : 'LEVEL');
                else this.play('MENU');
                return this.muted;
            },
            play(track) {
                if(!AudioSys.ctx || this.muted) return;
                this.ctx = AudioSys.ctx;
                if(this.currentTrack === track && this.isPlaying) return;
                this.stop();
                this.currentTrack = track;
                this.isPlaying = true;
                this.noteIndex = 0;
                this.nextNoteTime = this.ctx.currentTime + 0.1;
                this.scheduler();
            },
            stop() {
                this.isPlaying = false;
                clearTimeout(this.timerID);
                this.currentTrack = null;
            },
            scheduler() {
                if(!this.isPlaying) return;
                const lookahead = 0.1;
                const scheduleAhead = 0.1;
                while(this.nextNoteTime < this.ctx.currentTime + scheduleAhead) {
                    this.playPattern(this.noteIndex, this.nextNoteTime);
                    const tempo = (this.currentTrack === 'ENDLESS') ? (140 + Math.min(level*2, 40)) : 120;
                    const secondsPerBeat = 60.0 / tempo;
                    this.nextNoteTime += 0.25 * secondsPerBeat;
                    this.noteIndex++;
                }
                this.timerID = setTimeout(() => this.scheduler(), 25);
            },
            playPattern(index, time) {
                const step = index % 16;
                const freqs = { C2:65.4, Eb2:77.8, F2:87.3, G2:98, Bb2:116.5, C3:130.8, Eb3:155.6, F3:174.6, G3:196, Bb3:233 };
                let bassNote = null;
                let leadNote = null;
                if (this.currentTrack === 'MENU') {
                    if(step===0) bassNote = freqs.C2;
                    if(step===8) bassNote = freqs.G2;
                    if(step%4===0 && Math.random()>0.5) leadNote = freqs.Eb3;
                } else if (this.currentTrack === 'LEVEL') {
                    if(step%4===0) bassNote = freqs.C2;
                    if(step%4===2) bassNote = freqs.C2;
                    if(step===0 || step===6 || step===12) leadNote = freqs.G3;
                    if(step===2 || step===8 || step===14) leadNote = freqs.Eb3;
                } else if (this.currentTrack === 'ENDLESS') {
                    if(step%2===0) bassNote = (step<8) ? freqs.C2 : freqs.F2;
                    const arp = [freqs.C3, freqs.Eb3, freqs.G3, freqs.Bb3];
                    leadNote = arp[step % 4];
                }
                if (bassNote) this.synthNote(bassNote, time, 0.1, 'sawtooth', 0.15);
                if (leadNote) this.synthNote(leadNote, time, 0.1, 'square', 0.05);
            },
            synthNote(freq, time, dur, type, vol) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                filter.type = "lowpass";
                filter.frequency.value = 1000;
                osc.type = type;
                osc.frequency.value = freq;
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.ctx.destination);
                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + dur);
                osc.start(time);
                osc.stop(time + dur);
            }
        };
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height;
        function resize() { width = window.innerWidth; height = window.innerHeight; canvas.width = width; canvas.height = height; }
        window.addEventListener('resize', resize); resize();
        let gameState = 'START'; let score = 0; let level = 1; let startLevel = 1;
        let maxLevel = parseInt(localStorage.getItem('spaceWavesMaxLevel')) || 1;
        let bestScore = parseInt(localStorage.getItem('spaceWavesHigh')) || 0;
        let endlessBest = parseInt(localStorage.getItem('spaceWavesEndlessHigh')) || 0;
        let totalStars = parseInt(localStorage.getItem('spaceWavesStars')) || 0;
        let unlockedSkins = JSON.parse(localStorage.getItem('spaceWavesUnlockedSkins')) || ['classic'];
        let currentSkinId = localStorage.getItem('spaceWavesSkin') || 'classic';
        let gameMode = 'LEVELS';
        let lastGameMode = 'LEVELS';
        let gameSpeed = CONFIG.initialGameSpeed;
        let lastTime = 0; let inputActive = false; let currentTheme = THEMES[0];
        let shake = 0; let invulnerableTimer = 0;
        let timeScale = 1.0; let slowMoTimer = 0;
        let player = { x: 100, y: height/2, trail: [], angle: 0, shield: 0, flipped: false };
        let obstacles = []; let particles = []; let stars = []; let pickups = [];
        let menuAnimationFrame; let menuShipAngle = 0;
        document.getElementById('starDisplay').innerText = totalStars;
        function handleInputStart(e) { if(gameState==='PLAYING') inputActive=true; }
        function handleInputEnd(e) { inputActive=false; }
        canvas.addEventListener('mousedown', handleInputStart, {passive:true});
        canvas.addEventListener('touchstart', handleInputStart, {passive:true});
        canvas.addEventListener('mouseup', handleInputEnd, {passive:true});
        canvas.addEventListener('touchend', handleInputEnd, {passive:true});
        document.addEventListener('keydown', (e) => { if(e.code==='Space'||e.code==='ArrowUp'){e.preventDefault();handleInputStart(e);} });
        document.addEventListener('keyup', (e) => { if(e.code==='Space'||e.code==='ArrowUp') handleInputEnd(e); });
        function toggleSFX() { const isMuted = AudioSys.toggle(); document.getElementById('iconSfxOn').classList.toggle('hidden', isMuted); document.getElementById('iconSfxOff').classList.toggle('hidden', !isMuted); }
        function toggleMusic() { const isMuted = MusicSys.toggle(); document.getElementById('iconMusicOn').classList.toggle('hidden', isMuted); document.getElementById('iconMusicOff').classList.toggle('hidden', !isMuted); }
        function showFloatText(text, x, y, color) {
            const el = document.createElement('div'); el.innerText = text; el.className = 'float-text';
            el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.color = color;
            document.getElementById('floatTextContainer').appendChild(el);
            setTimeout(() => el.remove(), 1000);
        }
        function initStars() {
            stars = [];
            for(let i=0; i<150; i++) stars.push({ x:Math.random()*width, y:Math.random()*height, size:Math.random()*2+0.5, speed:Math.random()*0.5+0.2, layer:Math.floor(Math.random()*3)+1 });
        }
        function spawnPickup(y) {
            if (gameState !== 'PLAYING') return;
            const rand = Math.random();
            let type = 'star';
            if (rand < 0.3) type = 'shield';
            else if (rand < 0.5) type = 'slowmo';
            else type = 'star';
            pickups.push({ x: width + 40, y: y, type: type, size: 15, pulse: 0 });
        }
        function spawnPortal() {
            if (gameState !== 'PLAYING') return;
            obstacles.push({ x: width, y: 0, w: 50, h: height, type: 'portal_gate', triggered: false });
        }
        function spawnObstacle() {
            if (gameState !== 'PLAYING') return;
            if (gameMode === 'LEVELS' && score >= CONFIG.levelDistance) return;
            let effectiveLevel = level;
            if (gameMode === 'ENDLESS') {
                effectiveLevel = Math.floor(score / 1000) + 1;
            }
            if (effectiveLevel >= 3 && Math.random() < CONFIG.portalChance) {
                spawnPortal();
                return;
            }
            const difficultyModifier = Math.min((effectiveLevel - 1) * 6, 60);
            const gapHeight = Math.max(130, 190 - difficultyModifier);
            const minWallHeight = 50; const maxWallHeight = height - gapHeight - minWallHeight;
            let possibleTypes = [0, 1];
            if (effectiveLevel >= 2) possibleTypes.push(2, 3);
            if (effectiveLevel >= 3) possibleTypes.push(4, 5);
            if (effectiveLevel >= 4) possibleTypes.push(6, 7);
            if (effectiveLevel >= 5) possibleTypes.push(8, 9);
            if (effectiveLevel >= 6) possibleTypes.push(10);
            if (effectiveLevel >= 7) possibleTypes.push(11);
            if (effectiveLevel >= 8) possibleTypes.push(14);
            if (effectiveLevel >= 9) possibleTypes.push(12);
            if (effectiveLevel >= 11) possibleTypes.push(13);
            if (effectiveLevel >= 14) possibleTypes.push(15);
            if (effectiveLevel >= 18) possibleTypes.push(16);
            const type = possibleTypes[Math.floor(Math.random() * possibleTypes.length)];
            let pickupY = null;
            if (type === 0) {
                const topH = Math.random() * (maxWallHeight - minWallHeight) + minWallHeight;
                obstacles.push({ x: width, y: 0, w: CONFIG.obstacleWidth, h: topH, type: 'top' });
                obstacles.push({ x: width, y: topH + gapHeight, w: CONFIG.obstacleWidth, h: height - (topH + gapHeight), type: 'bottom' });
                pickupY = topH + gapHeight / 2;
            } else if (type === 1) {
                const h = 100; const y = Math.random() * (height - h - 100) + 50;
                obstacles.push({ x: width, y: y, w: CONFIG.obstacleWidth, h: h, type: 'block' });
                pickupY = (y > height/2) ? y/2 : (y+h+height)/2;
            } else if (type === 2) {
                obstacles.push({ x: width, y: height*0.2 + (Math.random()*50), w: 60, h: 60 });
                obstacles.push({ x: width, y: height*0.7 + (Math.random()*50), w: 60, h: 60 });
                pickupY = height / 2;
            } else if (type === 3) {
                obstacles.push({ x: width, y: height/4, w: 60, h: height/2 });
                pickupY = Math.random() > 0.5 ? height * 0.1 : height * 0.9;
            } else if (type === 4) {
                const s = 50;
                obstacles.push({ x: width, y: height*0.2, w: s, h: s });
                obstacles.push({ x: width + s + 10, y: height*0.5, w: s, h: s });
                obstacles.push({ x: width + (s*2) + 20, y: height*0.8, w: s, h: s });
                pickupY = height * 0.9;
            } else if (type === 5) {
                const s = 50; const c = height/2;
                obstacles.push({ x: width, y: c - 100, w: s, h: s });
                obstacles.push({ x: width + 80, y: c + 50, w: s, h: s });
                obstacles.push({ x: width + 160, y: c - 100, w: s, h: s });
                pickupY = height * 0.15;
            } else if (type === 6) {
                const gap = gapHeight * 1.0; const y = Math.random() * (height - gap - 100) + 50;
                obstacles.push({ x: width, y: 0, w: 30, h: y });
                obstacles.push({ x: width, y: y + gap, w: 30, h: height });
                pickupY = y + gap / 2;
            } else if (type === 7) {
                const w = 40;
                const toothH = height / 3.5;
                obstacles.push({ x: width, y: 0, w: w, h: toothH });
                obstacles.push({ x: width + 100, y: height - toothH, w: w, h: toothH });
                obstacles.push({ x: width + 200, y: 0, w: w, h: toothH });
                pickupY = height / 2;
            } else if (type === 8) {
                const squeeze = 160;
                const mid = height / 2;
                obstacles.push({ x: width, y: 0, w: 200, h: mid - squeeze/2 });
                obstacles.push({ x: width, y: mid + squeeze/2, w: 200, h: mid });
                pickupY = height / 2;
            } else if (type === 9) {
                const h = 100;
                const y = height/2 - h/2;
                obstacles.push({ x: width, y: y, w: 60, h: h, type: 'block', vy: 1.2, minY: 100, maxY: height - 100 });
                pickupY = height * 0.1;
            } else if (type === 10) {
                const tunnelGap = 110;
                const mid = height / 2;
                const len = 400;
                obstacles.push({ x: width, y: 0, w: len, h: mid - tunnelGap/2, type: 'top' });
                obstacles.push({ x: width, y: mid + tunnelGap/2, w: len, h: mid, type: 'bottom' });
                pickupY = mid;
            } else if (type === 11) {
                const h = 80;
                obstacles.push({ x: width, y: 50, w: 60, h: h, type: 'block', vy: 2, minY: 20, maxY: height/2 - 20 });
                obstacles.push({ x: width + 100, y: height - 150, w: 60, h: h, type: 'block', vy: -2, minY: height/2 + 20, maxY: height - 20 });
                pickupY = height / 2;
            } else if (type === 12) {
                const barH = height * 0.6;
                obstacles.push({ x: width, y: 50, w: 80, h: barH, type: 'block', vy: 2.5, minY: 20, maxY: height - barH - 20 });
                pickupY = height / 2;
            } else if (type === 13) {
                const w = 80;
                obstacles.push({ x: width, y: 0, w: w, h: height/2 - 60, vy: 0.8, minY: -50, maxY: height/2 - 60 });
                obstacles.push({ x: width, y: height/2 + 60, w: w, h: height/2, vy: -0.8, minY: height/2 + 60, maxY: height + 50 });
                pickupY = height / 2;
            } else if (type === 14) {
                const y = Math.random() * (height - 200) + 100;
                obstacles.push({ x: width, y: y, w: 40, h: 150, type: 'laser', active: true, timer: 0 });
                pickupY = y > height/2 ? y - 100 : y + 200;
            } else if (type === 15) {
                const holeSize = 130;
                const holeY = height / 2;
                obstacles.push({
                    x: width, y: -500, w: 60, h: 500 + holeY - holeSize/2,
                    vy: 1.5, minY: -600, maxY: -400
                });
                obstacles.push({ x: width, y: height/2 - 50, w: 60, h: 100, vy: 3, minY: 50, maxY: height - 150 });
                pickupY = height * 0.1;
            } else if (type === 16) {
                for(let i=0; i<5; i++) {
                    obstacles.push({
                        x: width + (i * 60),
                        y: Math.random() * (height - 40),
                        w: 30, h: 30
                    });
                }
                pickupY = height / 2;
            } else {
                const h = 100; const y = height/2;
                obstacles.push({ x: width, y: y, w: 60, h: h, type: 'block' });
                pickupY = height * 0.2;
            }
            if (pickupY !== null && Math.random() < CONFIG.pickupChance) {
                spawnPickup(pickupY);
            }
        }
        let obstacleTimer = 0;
        function createParticles(x, y, color, count, speed = 1) {
            for(let i=0; i<count; i++) particles.push({ x:x, y:y, vx:(Math.random()-0.5)*10*speed, vy:(Math.random()-0.5)*10*speed, life:1.0, color:color, size:Math.random()*3+1 });
        }
        function update(dt) {
            const effectiveDt = dt * timeScale;
            if (shake > 0) shake *= 0.9; if (shake < 0.5) shake = 0;
            const speedFactor = effectiveDt / 16.66;
            if (slowMoTimer > 0) {
                slowMoTimer -= dt/1000;
                if (slowMoTimer <= 0) {
                    timeScale = 1.0;
                    document.getElementById('slowMoIndicator').classList.add('hidden');
                }
            }
            if (invulnerableTimer > 0) invulnerableTimer -= dt/1000;
            if (gameState === 'START') {
                 for(let s of stars) { s.x -= s.speed * s.layer * 0.5 * speedFactor; if(s.x<0){ s.x=width; s.y=Math.random()*height; } }
                return;
            }
            if (gameState === 'LEVEL_TRANSITION') {
                for(let s of stars) { s.x -= s.speed * 60 * speedFactor; if(s.x<0){ s.x=width; s.y=Math.random()*height; } }
                player.y += ((height/2)-player.y)*0.1*speedFactor; player.x += 35*speedFactor; player.angle *= 0.8;
                player.trail.push({x:player.x, y:player.y}); if(player.trail.length>30) player.trail.shift();
                for(let p of player.trail) p.x -= 30*speedFactor;
                if (player.x > width + 200) showLevelCompleteUI();
                return;
            }
            if (gameState === 'LEVEL_COMPLETE') return;
            if (gameState !== 'PLAYING') return;
            score += (gameSpeed * speedFactor) / 10;
            if (gameMode === 'LEVELS') {
                const pct = Math.min((score / CONFIG.levelDistance) * 100, 100);
                document.getElementById('progressBar').style.width = `${pct}%`;
                if (score >= CONFIG.levelDistance) finishLevel();
            } else {
                let newLevel = Math.floor(score / 1000) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    currentTheme = THEMES[(level - 1) % THEMES.length];
                    gameSpeed += 0.5;
                    showFloatText("SPEED UP!", width/2, height/2, '#f0f');
                }
                document.getElementById('distanceDisplay').innerText = Math.floor(score);
                document.getElementById('progressBar').style.width = '100%';
            }
            let moveDir = player.flipped ? -1 : 1;
            if (inputActive) {
                player.y -= CONFIG.waveSpeed * speedFactor * moveDir;
                player.angle = -35 * (Math.PI/180) * moveDir;
            } else {
                player.y += CONFIG.waveSpeed * speedFactor * moveDir;
                player.angle = 35 * (Math.PI/180) * moveDir;
            }
            if (Math.random() > 0.5) {
                particles.push({ x:player.x-10, y:player.y+(Math.random()*10-5), vx:-Math.random()*4-2, vy:(Math.random()-0.5)*2, life:0.6, color:currentTheme.trail, size:Math.random()*2+1 });
            }
            player.trail.push({ x:player.x, y:player.y });
            if (player.trail.length > 25) player.trail.shift();
            for(let p of player.trail) p.x -= gameSpeed * speedFactor;
            if (player.y < 0 || player.y > height) { if (!invulnerableTimer) gameOver(); }
            for (let i = pickups.length - 1; i >= 0; i--) {
                let p = pickups[i]; p.x -= gameSpeed * speedFactor; p.pulse += 0.1;
                const dist = Math.sqrt(Math.pow(player.x-p.x, 2) + Math.pow(player.y-p.y, 2));
                if (dist < p.size + 20) {
                    if (p.type === 'shield') {
                        player.shield++; AudioSys.play('shieldGet'); showFloatText("SHIELD UP", player.x, player.y - 30, '#0ff');
                    } else if (p.type === 'slowmo') {
                        timeScale = 0.5; slowMoTimer = 3.0; AudioSys.play('slowmo'); document.getElementById('slowMoIndicator').classList.remove('hidden'); showFloatText("TIME WARP", player.x, player.y - 30, '#d946ef');
                    } else if (p.type === 'star') {
                        score += 50;
                        totalStars += 10;
                        localStorage.setItem('spaceWavesStars', totalStars);
                        document.getElementById('starDisplay').innerText = totalStars;
                        AudioSys.play('starGet');
                        showFloatText("+10 STARS", player.x, player.y - 30, '#fbbf24');
                    }
                    pickups.splice(i, 1); createParticles(player.x, player.y, '#ffffff', 10, 1);
                } else if (p.x < -50) pickups.splice(i, 1);
            }
            obstacleTimer += dt * timeScale;
            const spawnTime = CONFIG.spawnRate / (gameSpeed / 6);
            if (obstacleTimer > spawnTime) { spawnObstacle(); obstacleTimer = 0; }
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.x -= gameSpeed * speedFactor;
                if (obs.type === 'laser') {
                    obs.timer += dt/1000;
                    if (obs.timer > 2.0) { obs.active = !obs.active; obs.timer = 0; }
                }
                if (!obs.grazed && !invulnerableTimer) {
                    const distToObs = Math.abs(player.x - (obs.x + obs.w/2));
                    const distToY = Math.abs(player.y - (obs.y + obs.h/2));
                    if (distToObs < (obs.w/2 + 20) && distToY < (obs.h/2 + 30) && distToY > (obs.h/2 + 8)) {
                        obs.grazed = true;
                        showFloatText("NEAR MISS!", player.x, player.y - 40, '#fbbf24');
                        score += 5;
                        AudioSys.play('graze');
                    }
                }
                let collision = false;
                if (player.x+8 > obs.x && player.x-8 < obs.x+obs.w && player.y+8 > obs.y && player.y-8 < obs.y+obs.h) {
                    if (obs.type === 'laser') {
                        if (obs.active) collision = true;
                    } else if (obs.type === 'portal_gate') {
                        if (!obs.triggered) {
                            obs.triggered = true;
                            player.flipped = !player.flipped;
                            AudioSys.play('portal');
                            showFloatText("GRAVITY FLIP!", player.x, player.y - 30, '#f97316');
                            createParticles(player.x, player.y, '#f97316', 30, 2);
                            const gravInd = document.getElementById('gravityIndicator');
                            if (player.flipped) gravInd.classList.remove('hidden'); else gravInd.classList.add('hidden');
                        }
                        collision = false;
                    } else {
                        collision = true;
                    }
                }
                if (collision) {
                    if (invulnerableTimer > 0) {}
                    else if (player.shield > 0) {
                        player.shield--; invulnerableTimer = 1.5; shake = 20; AudioSys.play('shieldBreak');
                        createParticles(player.x, player.y, '#00ffff', 25, 3);
                    } else { gameOver(); }
                }
                if (obs.x + obs.w + 100 < 0) obstacles.splice(i, 1);
            }
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.x += p.vx * speedFactor; p.y += p.vy * speedFactor; p.life -= 0.03 * speedFactor;
                if (p.life <= 0) particles.splice(i, 1);
            }
            for (let s of stars) { s.x -= s.speed * s.layer * (gameSpeed/4) * speedFactor; if(s.x<0){ s.x=width; s.y=Math.random()*height; } }
        }
        function draw() {
            ctx.save();
            if (shake > 0) { ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake); }
            let grad = ctx.createLinearGradient(0, 0, 0, height);
            grad.addColorStop(0, '#050510'); grad.addColorStop(1, '#0a0a1a');
            ctx.fillStyle = grad; ctx.fillRect(-10, -10, width+20, height+20);
            const pulse = 1 + Math.sin(Date.now()/300)*0.05;
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.05*pulse})`; ctx.lineWidth = 1;
            const gridSize = 80; const scroll = (Date.now()/15*(gameSpeed/5))%gridSize;
            ctx.save();
            for(let y=height/2; y<height; y+=40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(width, y); ctx.stroke(); }
            ctx.restore();
            ctx.fillStyle = '#fff';
            for (let s of stars) {
                ctx.globalAlpha = 0.4 + (s.layer*0.2);
                if (gameState === 'LEVEL_TRANSITION') {
                    ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x+80, s.y); ctx.strokeStyle='#fff'; ctx.lineWidth=s.size; ctx.stroke();
                } else {
                    ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
            if (gameState === 'PLAYING' || gameState === 'GAME_OVER' || gameState === 'LEVEL_TRANSITION') {
                ctx.shadowBlur = 20; ctx.shadowColor = currentTheme.trail;
                if (player.trail.length > 1) {
                    ctx.beginPath(); ctx.moveTo(player.trail[0].x, player.trail[0].y);
                    for (let i=1; i<player.trail.length; i++) {
                        ctx.lineWidth = 2 + (i/player.trail.length)*4; ctx.lineTo(player.trail[i].x, player.trail[i].y);
                        ctx.stroke(); ctx.beginPath(); ctx.moveTo(player.trail[i].x, player.trail[i].y);
                    }
                    ctx.lineTo(player.x, player.y); ctx.strokeStyle = currentTheme.trail; ctx.stroke();
                }
                for (let p of pickups) {
                    const scale = 1 + Math.sin(p.pulse)*0.2;
                    ctx.save(); ctx.translate(p.x, p.y); ctx.scale(scale, scale);
                    ctx.beginPath();
                    if (p.type === 'shield') {
                        ctx.arc(0, 0, p.size, 0, Math.PI*2);
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)'; ctx.shadowColor = '#0ff';
                    } else if (p.type === 'slowmo') {
                        ctx.arc(0, 0, p.size, 0, Math.PI*2);
                        ctx.fillStyle = 'rgba(217, 70, 239, 0.5)'; ctx.shadowColor = '#d946ef';
                    } else if (p.type === 'star') {
                        for(let i=0; i<5; i++){
                            ctx.lineTo(Math.cos((18+i*72)*Math.PI/180)*p.size, -Math.sin((18+i*72)*Math.PI/180)*p.size);
                            ctx.lineTo(Math.cos((54+i*72)*Math.PI/180)*p.size/2, -Math.sin((54+i*72)*Math.PI/180)*p.size/2);
                        }
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(251, 191, 36, 0.8)'; ctx.shadowColor = '#fbbf24';
                    }
                    ctx.shadowBlur = 20; ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.restore();
                }
                if (gameState === 'PLAYING' || gameState === 'LEVEL_TRANSITION') {
                    ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle);
                    if (player.flipped) ctx.scale(1, -1);
                    if (invulnerableTimer > 0 && Math.floor(Date.now()/50)%2===0) ctx.globalAlpha = 0.5;
                    if (player.shield > 0) {
                        for(let i=0; i<player.shield; i++) {
                            ctx.beginPath(); ctx.arc(0, 0, 25+(i*6), 0, Math.PI*2);
                            ctx.strokeStyle = `rgba(0, 255, 255, ${0.4 + Math.sin(Date.now()/100)*0.2})`;
                            ctx.lineWidth = 2; ctx.stroke();
                        }
                    }
                    const skinColor = SKINS.find(s => s.id === currentSkinId)?.color || '#fff';
                    ctx.shadowColor = skinColor; ctx.shadowBlur = 15;
                    ctx.beginPath();
                    if (currentSkinId === 'interceptor') { ctx.moveTo(25, 0); ctx.lineTo(-12, 10); ctx.lineTo(-5, 0); ctx.lineTo(-12, -10); }
                    else if (currentSkinId === 'orb') { ctx.arc(0, 0, 14, 0, Math.PI*2); }
                    else if (currentSkinId === 'dart') { ctx.moveTo(18, 0); ctx.lineTo(-10, 10); ctx.lineTo(-10, -10); }
                    else { ctx.moveTo(18, 0); ctx.lineTo(-12, 10); ctx.lineTo(-5, 0); ctx.lineTo(-12, -10); }
                    ctx.closePath();
                    ctx.fillStyle = '#050510'; ctx.fill(); ctx.strokeStyle = skinColor; ctx.lineWidth = 2; ctx.stroke();
                    ctx.restore(); ctx.globalAlpha = 1;
                }
                ctx.shadowColor = currentTheme.obs; ctx.shadowBlur = 10;
                ctx.fillStyle = currentTheme.obsFill; ctx.strokeStyle = currentTheme.obs; ctx.lineWidth = 2;
                for (let obs of obstacles) {
                    if (obs.type === 'laser') {
                        ctx.fillStyle = '#222'; ctx.fillRect(obs.x, obs.y, obs.w, 10); ctx.fillRect(obs.x, obs.y + obs.h - 10, obs.w, 10);
                        if (obs.active) {
                            ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 20; ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 4;
                            ctx.beginPath(); ctx.moveTo(obs.x + obs.w/2, obs.y + 10); ctx.lineTo(obs.x + obs.w/2, obs.y + obs.h - 10);
                            if (Math.random() > 0.1) ctx.stroke();
                        } else {
                            ctx.strokeStyle = 'rgba(255, 0, 0, 0.2)'; ctx.lineWidth = 1;
                            ctx.beginPath(); ctx.moveTo(obs.x + obs.w/2, obs.y + 10); ctx.lineTo(obs.x + obs.w/2, obs.y + obs.h - 10); ctx.stroke();
                        }
                    } else if (obs.type === 'portal_gate') {
                        const flicker = Math.random() * 10;
                        const gradient = ctx.createLinearGradient(obs.x, 0, obs.x + obs.w, 0);
                        gradient.addColorStop(0, 'rgba(249, 115, 22, 0)');
                        gradient.addColorStop(0.5, 'rgba(249, 115, 22, 0.6)');
                        gradient.addColorStop(1, 'rgba(249, 115, 22, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(obs.x - flicker, 0, obs.w + (flicker*2), height);
                        ctx.beginPath(); ctx.moveTo(obs.x + obs.w/2, 0); ctx.lineTo(obs.x + obs.w/2, height);
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.shadowColor = '#f97316'; ctx.shadowBlur = 30; ctx.stroke();
                    } else {
                        ctx.fillRect(obs.x, obs.y, obs.w, obs.h); ctx.strokeRect(obs.x, obs.y, obs.w, obs.h);
                        ctx.beginPath(); ctx.moveTo(obs.x+5, obs.y+5); ctx.lineTo(obs.x+15, obs.y+5);
                        ctx.moveTo(obs.x+5, obs.y+obs.h-5); ctx.lineTo(obs.x+15, obs.y+obs.h-5);
                        ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.stroke(); ctx.strokeStyle = currentTheme.obs;
                    }
                }
                ctx.shadowBlur = 0; ctx.globalCompositeOperation = 'lighter';
                for (let p of particles) {
                    ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                }
                ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1;
            }
            ctx.restore();
        }
        function startMenuLoop() {
            if (menuAnimationFrame) cancelAnimationFrame(menuAnimationFrame);
            const mc = document.getElementById('menuShipCanvas'); const mctx = mc.getContext('2d');
            document.getElementById('menuMaxLevel').innerText = maxLevel;
            document.getElementById('menuEndlessBest').innerText = Math.floor(endlessBest);
            const rankEl = document.getElementById('menuRank');
            if (bestScore < 1000) { rankEl.innerText = "ROOKIE"; rankEl.className = "stat-val text-gray-400"; }
            else if (bestScore < 5000) { rankEl.innerText = "PILOT"; rankEl.className = "stat-val text-cyan-400"; }
            else if (bestScore < 10000) { rankEl.innerText = "ACE"; rankEl.className = "stat-val text-purple-400"; }
            else { rankEl.innerText = "LEGEND"; rankEl.className = "stat-val text-yellow-400"; }
            if(!MusicSys.muted && !MusicSys.isPlaying && gameState === 'START') {
                MusicSys.play('MENU');
            }
            function menuLoop() {
                if (gameState !== 'START') return;
                mctx.clearRect(0, 0, 240, 140); menuShipAngle += 0.02;
                mctx.save(); mctx.translate(120, 70 + Math.sin(Date.now()/800)*8);
                mctx.scale(Math.sin(menuShipAngle)*0.15+1, 1); mctx.rotate(Math.sin(Date.now()/1500)*0.1);
                const skinColor = SKINS.find(s => s.id === currentSkinId)?.color || '#fff';
                mctx.shadowBlur = 20; mctx.shadowColor = skinColor; mctx.strokeStyle = skinColor; mctx.lineWidth = 3; mctx.fillStyle = '#050510';
                mctx.beginPath();
                if (currentSkinId === 'interceptor') { mctx.moveTo(40, 0); mctx.lineTo(-20, 16); mctx.lineTo(-10, 0); mctx.lineTo(-20, -16); }
                else if (currentSkinId === 'orb') { mctx.arc(0, 0, 25, 0, Math.PI*2); }
                else if (currentSkinId === 'dart') { mctx.moveTo(30, 0); mctx.lineTo(-16, 16); mctx.lineTo(-16, -16); }
                else { mctx.moveTo(30, 0); mctx.lineTo(-20, 16); mctx.lineTo(-10, 0); mctx.lineTo(-20, -16); }
                mctx.closePath(); mctx.fill(); mctx.stroke(); mctx.restore();
                menuAnimationFrame = requestAnimationFrame(menuLoop);
            }
            menuLoop();
        }
        function gameLoop(timestamp) {
            const dt = timestamp - lastTime; lastTime = timestamp; update(dt); draw();
            requestAnimationFrame(gameLoop);
        }
        function finishLevel() { if (gameState === 'LEVEL_TRANSITION') return; gameState = 'LEVEL_TRANSITION'; AudioSys.play('warp'); }
        function showLevelCompleteUI() {
            gameState = 'LEVEL_COMPLETE'; document.getElementById('nextLevelNum').innerText = level + 1;
            document.getElementById('hud').classList.add('hidden'); document.getElementById('progressContainer').style.display = 'none';
            const screen = document.getElementById('levelCompleteScreen'); screen.classList.remove('hidden');
            requestAnimationFrame(() => { screen.classList.add('ui-visible'); });
            if (level + 1 > maxLevel) { maxLevel = level + 1; localStorage.setItem('spaceWavesMaxLevel', maxLevel); }
        }
        function nextLevel() { startLevel = level + 1; startGame('LEVELS'); }
        function gameOver() {
            if (gameState === 'LEVEL_COMPLETE' || gameState === 'LEVEL_TRANSITION') return;
            gameState = 'GAME_OVER'; shake = 30; createParticles(player.x, player.y, currentTheme.trail, 50, 2); AudioSys.play('crash');
            MusicSys.stop();
            if (gameMode === 'ENDLESS') {
                if (score > endlessBest) {
                    endlessBest = score;
                    localStorage.setItem('spaceWavesEndlessHigh', endlessBest);
                }
            } else {
                if (score > bestScore) {
                    bestScore = score;
                    localStorage.setItem('spaceWavesHigh', bestScore);
                }
            }
            document.getElementById('hud').classList.add('hidden'); document.getElementById('progressContainer').style.display = 'none';
            setTimeout(() => { const screen = document.getElementById('gameOverScreen'); screen.classList.remove('hidden'); requestAnimationFrame(() => { screen.classList.add('ui-visible'); }); }, 600);
        }
        function resetGame() {
            player.y = height/2; player.x = 100; player.trail = []; player.angle = 0; player.shield = 0; player.flipped = false;
            obstacles = []; particles = []; pickups = [];
            level = startLevel; score = 0; shake = 0; invulnerableTimer = 0; timeScale = 1.0; slowMoTimer = 0;
            currentTheme = THEMES[(level - 1) % THEMES.length]; gameSpeed = CONFIG.initialGameSpeed + (level * 0.5);
            inputActive = false; obstacleTimer = 0;
            document.getElementById('levelDisplay').innerText = level;
            document.getElementById('distanceDisplay').innerText = '0';
            document.getElementById('progressBar').style.width = '0%';
            document.getElementById('slowMoIndicator').classList.add('hidden');
            document.getElementById('gravityIndicator').classList.add('hidden');
            if (gameMode === 'ENDLESS') {
                document.getElementById('levelContainer').classList.add('hidden');
                document.getElementById('scoreContainer').classList.remove('hidden');
                document.getElementById('progressContainer').style.display = 'none';
            } else {
                document.getElementById('levelContainer').classList.remove('hidden');
                document.getElementById('scoreContainer').classList.add('hidden');
                document.getElementById('progressContainer').style.display = 'block';
            }
        }
        function startGame(mode = 'LEVELS') {
            gameMode = mode; lastGameMode = mode;
            AudioSys.init();
            MusicSys.play(mode === 'ENDLESS' ? 'ENDLESS' : 'LEVEL');
            if (menuAnimationFrame) cancelAnimationFrame(menuAnimationFrame);
            gameState = 'PLAYING'; resetGame();
            document.querySelectorAll('.ui-layer').forEach(el => { if(el.id !== 'hud') { el.classList.remove('ui-visible'); el.classList.add('hidden'); } });
            document.getElementById('hud').classList.remove('hidden');
        }
        function goToMenu() {
            document.querySelectorAll('.ui-layer').forEach(el => { el.classList.remove('ui-visible'); el.classList.add('hidden'); });
            const start = document.getElementById('startScreen'); start.classList.remove('hidden'); gameState = 'START';
            MusicSys.play('MENU');
            startMenuLoop(); requestAnimationFrame(() => { start.classList.add('ui-visible'); });
        }
        function showMenu(menuName) {
            document.querySelectorAll('.ui-layer').forEach(el => { el.classList.remove('ui-visible'); el.classList.add('hidden'); });
            let target;
            if (menuName === 'start') { target = document.getElementById('startScreen'); startMenuLoop(); }
            else if (menuName === 'levels') { renderLevelsGrid(); target = document.getElementById('levelsScreen'); }
            else if (menuName === 'skins') {
                renderSkinsGrid();
                document.getElementById('skinMenuStars').innerText = totalStars;
                target = document.getElementById('skinsScreen');
            }
            else if (menuName === 'credits') { target = document.getElementById('creditsScreen'); }
            else if (menuName === 'tutorial') { target = document.getElementById('tutorialScreen'); }
            if (target) { target.classList.remove('hidden'); requestAnimationFrame(() => { target.classList.add('ui-visible'); }); }
        }
        function renderLevelsGrid() {
            const grid = document.getElementById('levelsGrid');
            grid.innerHTML = '';
            for (let i = 1; i <= 30; i++) {
                const btn = document.createElement('div');
                const isLocked = i > maxLevel;
                btn.className = `menu-btn interactive ${isLocked ? 'locked' : ''} ${i === startLevel ? 'selected' : ''}`;
                btn.innerHTML = `<div class="text-2xl mb-1">${i}</div><div class="text-xs text-gray-400">${isLocked ? 'LOCKED' : 'SECTOR'}</div>`;
                if (!isLocked) {
                    btn.onclick = () => { startLevel = i; renderLevelsGrid(); };
                }
                grid.appendChild(btn);
            }
        }
        function buySkin(skinId, price) {
            if (totalStars >= price) {
                totalStars -= price;
                unlockedSkins.push(skinId);
                localStorage.setItem('spaceWavesStars', totalStars);
                localStorage.setItem('spaceWavesUnlockedSkins', JSON.stringify(unlockedSkins));
                document.getElementById('skinMenuStars').innerText = totalStars;
                document.getElementById('starDisplay').innerText = totalStars;
                AudioSys.play('buy');
                renderSkinsGrid();
            }
        }
        function renderSkinsGrid() {
            const grid = document.getElementById('skinsGrid'); grid.innerHTML = '';
            SKINS.forEach(skin => {
                const isUnlocked = unlockedSkins.includes(skin.id);
                const isSelected = skin.id === currentSkinId;
                const btn = document.createElement('div');
                let baseClass = `menu-btn interactive ${isSelected ? 'selected' : ''}`;
                if (!isUnlocked) baseClass += ' locked';
                btn.className = baseClass;
                btn.style.display = 'flex'; btn.style.flexDirection = 'column'; btn.style.alignItems = 'center'; btn.style.gap = '10px';
                const cvs = document.createElement('canvas'); cvs.width = 60; cvs.height = 60;
                drawSkinPreview(cvs, skin.id, skin.color);
                const label = document.createElement('span'); label.innerText = skin.name;
                btn.appendChild(cvs); btn.appendChild(label);
                if (isUnlocked) {
                    btn.onclick = () => {
                        currentSkinId = skin.id; player.skin = skin.id;
                        localStorage.setItem('spaceWavesSkin', skin.id); renderSkinsGrid();
                    };
                } else {
                    const buyBtn = document.createElement('div');
                    buyBtn.className = 'mt-2 text-sm font-bold ' + (totalStars >= skin.price ? 'text-green-400' : 'text-red-400');
                    buyBtn.innerText = `BUY: ${skin.price}`;
                    btn.appendChild(buyBtn);
                    if (totalStars >= skin.price) {
                        btn.classList.remove('locked');
                        btn.onclick = () => buySkin(skin.id, skin.price);
                    }
                }
                grid.appendChild(btn);
            });
        }
        function drawSkinPreview(cvs, skinId, color) {
            const ctx = cvs.getContext('2d'); const w = cvs.width, h = cvs.height;
            ctx.clearRect(0, 0, w, h); ctx.save(); ctx.translate(w/2, h/2); ctx.rotate(-45 * Math.PI / 180); ctx.scale(1.5, 1.5);
            ctx.shadowBlur = 10; ctx.shadowColor = color; ctx.beginPath();
            if (skinId === 'interceptor') { ctx.moveTo(15, 0); ctx.lineTo(-10, 8); ctx.lineTo(-5, 0); ctx.lineTo(-10, -8); }
            else if (skinId === 'orb') { ctx.arc(0, 0, 10, 0, Math.PI*2); }
            else if (skinId === 'dart') { ctx.moveTo(12, 0); ctx.lineTo(-8, 8); ctx.lineTo(-8, -8); }
            else { ctx.moveTo(10, 0); ctx.lineTo(-10, 7); ctx.lineTo(-5, 0); ctx.lineTo(-10, -7); }
            ctx.closePath(); ctx.fillStyle = '#050510'; ctx.fill(); ctx.strokeStyle = color; ctx.lineWidth = 2; ctx.stroke(); ctx.restore();
        }
        initStars(); startMenuLoop(); requestAnimationFrame(gameLoop);
    </script>
</body>
</html>